(load "lexical_address.scm")
(define env1 '((a 1)(b 2)(c 3)))
(define env2 '((x a)(y b)(z c)))
(define exAdd1 '(+ 1 2))
(define exAdd2 '(+ 1 (+ 2 3)))
(define exLamb1 '(((lambda (x y) (+ x y))1)2))
(define exLamb2 '(((lambda (x y) (+ x (+ y z)))1)2))
;;----------------------------------------------------------------------------------------------

(define (succ n)
    (+ n 1)
)
(define (pred n)
    (- n 1)
)


(define (addition n m)
    (if (= m 0) n
                (addition (succ n) (pred m))
    )
)
(define (multiplication m n)
    (if (= n 1) m
                (addition m (multiplication m  (pred n)))

    )
)
(define (lexical_address in-exp)
    (cond
        ((symbol? in-exp) in-exp)
        ((null? in-exp) in-exp)
        ((list? (car in-exp)) (cons (lexical_address (car in-exp)) (lexical_address (cdr in-exp))))
        ((eq? (car in-exp) 'lambda)
            (let ((new_exp (change (cadr in-exp) (caddr in-exp) 1)))
                (cons 'lambda (cons (length(cadr in-exp)) (cons (lexical_address new_exp) '())))))
        ((symbol? (car in-exp)) (cons (lexical_address (car in-exp)) (lexical_address (cdr in-exp))))
        (else (cons (car in-exp) (lexical_address (cdr in-exp))))
    )
)

(define (change binds ls index)
    (define (changeOne sym lvIndex ls)
        (cond
            ((null? ls) ls)
            ((eq? (car ls) sym) (cons lvIndex (changeOne sym lvIndex (cdr ls))))
            ((list? (car ls)) (cons (changeOne sym lvIndex (car ls)) (changeOne sym lvIndex (cdr ls))))
            ((eq? (car ls) 'lambda)
                (cons 'lambda (cons (cadr ls) (cons (changeOne sym (cons (+ 1 (car lvIndex)) (cdr lvIndex)) (caddr ls)) '()))))
            (else (cons (car ls) (changeOne sym lvIndex (cdr ls))))
        )
    )
    (cond
        ((null? (car ls)) ls)
        ((null? binds) ls)
        (else (change (cdr binds) (changeOne (car binds) (cons 1 (cons index '())) ls) (+ index 1)))
    )
)

(define (parse in-exp)
    (define (parse_ in-exp)
        (cond
            ((null? in-exp) in-exp)
            ((number? (car in-exp))
                (cons (cons 'number (cons (car in-exp) '())) (parse_ (cdr in-exp))))
            ((or (eq? '+ (car in-exp))(eq? '* (car in-exp)))
                (cons (cons 'num-op (cons (car in-exp) '())) (parse_ (cdr in-exp))) )
            ((eq? 'lambda (car in-exp))
                (cons 'lambda (cons (cadr in-exp) (cons (parse (caddr in-exp)) '()))))
                ;(lambda_ast in-exp))
            ((symbol? (car in-exp))
                (cons (cons 'var-ref (cons (car in-exp) '())) (parse_ (cdr in-exp))))
            (else (cons (parse (car in-exp)) (parse_ (cdr in-exp))))
        )
    )
    (parse_ in-exp)
)
(define (lambda_ast lam-exp)
    (let (
            (bind (cadr lam-exp)) (elam-exp (caddr lam-exp)))
            (cons 'lambda (cons (cons 'bind (cons bind '())) (cons (parse elam-exp) '())))
    )
)
(define (num_ast num-exp)
    (let ((op (car num-exp)) (expList (parse (cdr num-exp))))
        (cons 'num-op (cons op (cons expList '())))
    )
)

(define (basic-lookup var env)
    (if(null? env) var
        (if (eq? (caar env) var) (cadar env)
            (basic-lookup var (cdr env))
        )
    )
)

(define (rec_subs ls old new)
    (if(null? ls) ls
        (cond
            ((eq? (car ls) old) (cons new (rec_subs (cdr ls) old new)))
            ((list? (car ls)) (cons (rec_subs (car ls) old new) (rec_subs (cdr ls) old new)))
            (else (cons (car ls) (rec_subs (cdr ls) old new)))
        )
    )
)

(define (lookup ex env)
    (cond
        ((null? ex) ex)
        ((list? (car ex))
            (if(eq? 'var-ref (caar ex))
                (cons (basic-lookup (cadar ex) env) (lookup (cdr ex) env))
                (cons (lookup (car ex) env) (lookup (cdr ex) env))
            )
        )
        (else (cons (car ex) (lookup (cdr ex) env)))
    )
)

(define (getParameters app)
    (cond
        ((null? app) app)
        ((not(eq? (car app) 'lambda)) (cons (cadr app) (getParameters (car app))))
        (else '())
    )
)

(define (getAbstraction app)
    (cond
        ((null? app) app)
        ((not(eq? (car app) 'lambda)) (getAbstraction (car app)))
        (else app)
    )
)

(define (subs expr old new)
    (cond
        ((null? expr) '())
        ((equal? (car expr) old) (cons new (subs (cdr expr) old new)))
        ((list? (car expr))
            (if(eq? 'lambda (caar expr))
                (cons (subs (car expr) (cons (+ (car old) 1) (cdr old)) new) (subs (cdr expr) old new))
                (cons (subs (car expr) old new) (subs (cdr expr) old new))
            )
        )
        (else (cons (car expr) (subs (cdr expr) old new)))
    )
)

(define (beta-reduce appl)
    (my_beta_reduce (getAbstraction appl) (getParameters appl))
)

(define (beta-reduce_appl appl)
    (my_beta_reduce (lexical_address (getAbstraction appl)) (getParameters appl))
)


(define (my_beta_reduce abst parLs)
    (cond
        ((null? (cadr abst)) abst)
        (else (bindSubst (cadr abst) 1 abst parLs))
    )
)

(define (bindSubst n cnt abst parLs)
    (cond
        ((or (> cnt n) (null? parLs))
            (if(= (cadr abst) 0) (caddr abst) abst))
        (else (bindSubst n (+ cnt 1) (cons (car abst) (cons (- (cadr abst) 1) (list(subs (caddr abst) (cons '1 (cons cnt '())) (car parLs))))) (cdr parLs)))
    )
)

(define (reduce expr)
    (cond
        ((number? expr) expr)
        ((null? expr) '())
        ((eq? (car expr) '+) (addition (reduce (cadr expr)) (reduce (caddr expr))))
        ((eq? (car expr) '+) (multiplication (reduce (cadr expr)) (reduce (caddr expr))))
        ((eq? (car expr) 'lambda) (beta-reduce (lexical_address expr)))
        ((eq? (car expr) 'number) (cadr expr))
        ((list? (car expr))
            (cond
                ((eq? (caar expr) 'number) (cadr expr))
                ((eq? (caar expr) 'num-op)
                    (if (eq? (cadar expr) '+)
                        (addition (reduce (cadr expr)) (reduce  (caddr expr)))
                        (multiplication (reduce (cadr expr)) (reduce  (caddr expr)))
                    )
                )
                (else (reduce (beta-reduce_appl expr)))
            )
        )
    )
)

(define (my_reduce expr env)
    (let ((subst_expr (lookup (parse expr) env))) (reduce subst_expr))
)
